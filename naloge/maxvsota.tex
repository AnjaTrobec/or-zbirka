\begin{naloga}{?}{Izpit OR 12.5.2016}
\begin{vprasanje}
Dan je seznam števil $A = [a_1, a_2, \dots, a_n]$.
Želimo poiskati maksimalno vsoto takega podzaporedja v $A$,
ki ne vsebuje dveh zaporednih členov seznama.

\begin{enumerate}[(a)]
\item Napiši rekurzivne enačbe za reševanje opisanega problema.

\item S pomočjo dinamičnega programiranja napiši algoritem,
ki rešuje dani problem.
Kakšna je njegova časovna zahtevnost?
\end{enumerate}
\end{vprasanje}
\begin{odgovor}

\begin{enumerate}[(a)]

\item Naj bo $V_i$ največja vsota nesosednjih členov zaporedja, ki jo lahko dobimo,
če gledamo samo elemente od 1 do $i$, in vključuje $a_i$.

\begin{align*}
V_{-1} &= 0 \\
V_0 &= 0 \\
V_i &= \max_{j < i - 1}\left(V_j\right) + a_i
\qquad (1 \le i \le n)
\end{align*}

Vidimo, da na $i$-tem koraku iščemo največjo prejšnjo nesosednjo vsoto $V_j$,
ki ji bomo priključili element $a_i$, torej izračunamo največjo vsoto, 
ki zadošča pogoju nesosednosti in vključuje člen $a_i$.

Za izračun vrednosti $V_i$ moramo imeti podane že vse prejšnje $V_j$, torej vse $V_j$, za $j < i$.
To dosežemo tako, da te vrednosti računamo naraščajoče z začetkom v $1$ in koncem v $n$.
Po izračunu vseh vrednosti $V_i$ bo maximalna vrednost iskanega problema enaka $\max_{1 \leq i \leq n}(V_i)$.

Podamo lahko še alternativno rekurzivno zvezo za ta problem, in sicer 
definirajmo $U_i$ kot največjo vsoto nesosednjih členov zaporadja, 
ki jo dobimo, če gledamo samo elemente od 1 do $i$.
Ta definicija se razlikuje od zgornje po tem, da dobljena vsota ne vključuje nujno elementa $a_i$.

\begin{align*}
U_{-1} &= 0 \\
U_0 &= 0 \\
U_i &= \max\left(U_{j - 2} + a_i, U_{j - 1}\right)
\qquad (1 \le i \le n)
\end{align*}

Ideja tega rekurzivnega zapisa je podobna zgornji,
le da se namesto iska\-nja maksimuma odloči,
če bo $i$-ti člen vključila v vsoto oziroma ga bo izpustila.

Vrstni red iskanja vrednosti $U_i$ določimo z naraščajočim zaporedjem indeksov $i$, ko $1\leq i \leq n$, 
saj imamo tako pred reševanjem problema $U_i$ definirane vse vrednosti prej.
Ko izračunamo vse vrednosti $U_i$, je maximum vsote zaporedja enak $U_n$,
kar sledi neposredno iz definicije vrednosti $U_n$.

\item Algoritem bo sledil drugi rekurzivni zvezi.

\begin{small}
\begin{algorithmic}
\Function{maxvsota}{$a$}
	\State $n \gets \length(a)$
	\State $U \gets$ slovar z vrednostmi $0$ in ključi $i$, za $i \leq -1 \leq n$
	\For{$i = 1, 2, \dots, n$}
		\State $U[i] \gets \max(U[i-2] + a[i], U[i-1])$
	\EndFor
	\Return $U[n]$
\EndFunction
\end{algorithmic}
\end{small}

Algoritem enostavno upošteva drugo rekurzivno zvezo in iterativno, naraščajoče po $i$, pridobiva 
vrednosti $U[i]$, dokler ne pride do $U[n]$, kar vrne kot optimalno vrednost.
Časovna zahtevnost je očitno $O(n)$, saj zanko izvedemo enkrat, v njej pa porabimo konstantno časa.

Izvajanje algoritma na primeru $a = [-2, 3, 10, -4, 7, 21, 5, 0, -10]$ si lahko ogledamo v tabeli ~\tab.

Algoritem lahko nadgradimo tako, da vrne tudi zaporedje, ki maksimizira vsoto.
To dosežemo s seznamom predhodnikov, v katerega na vsaki iteraciji shranimo indeks, ki smo ga uporabili v izračunu $U_i$, torej $i-2$ ali pa $i-1$.
Po koncu  izvajanja zanke kot v algoritmu {\sc Topo} iz naloge~\res[topo] dobivamo pot, med tem pa dodajamo le tiste člene z razmikom 2, 
saj so to tisti, ki smo jih dejansko prišteli v vsoto.

\begin{tabela}
$$
\begin{array}{c|ccccccccccc}
i & V_{-1} & V_0 & V_1 & V_2 & V_3 & V_4 & V_5 & V_6 & V_7 & V_8 & V_9 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
2 & 0 & 0 & 0 & 3 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
3 & 0 & 0 & 0 & 3 & 10 & 0 & 0 & 0 & 0 & 0 & 0 \\
4 & 0 & 0 & 0 & 3 & 10 & 10 & 0 & 0 & 0 & 0 & 0 \\
5 & 0 & 0 & 0 & 3 & 10 & 10 & 17 & 0 & 0 & 0 & 0 \\
6 & 0 & 0 & 0 & 3 & 10 & 10 & 17 & 31 & 0 & 0 & 0 \\
7 & 0 & 0 & 0 & 3 & 10 & 10 & 17 & 31 & 31 & 0 & 0 \\
8 & 0 & 0 & 0 & 3 & 10 & 10 & 17 & 31 & 31 & 31 & 0 \\
9 & 0 & 0 & 0 & 3 & 10 & 10 & 17 & 31 & 31 & 31 & 31 \\
\end{array}
$$
\podnaslov{Potek izvajanja algoritma {\sc maxvsota}}
\end{tabela}

\end{enumerate}

\end{odgovor}
\end{naloga}
