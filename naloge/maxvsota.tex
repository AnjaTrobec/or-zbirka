\begin{naloga}{?}{Izpit OR 12.5.2016}
\begin{vprasanje}
Dan je seznam števil $A = [a_1, a_2, \dots, a_n]$.
Želimo poiskati maksimalno vsoto takega podzaporedja v $A$,
ki ne vsebuje dveh zaporednih členov seznama.

\begin{enumerate}[(a)]
\item Napiši rekurzivne enačbe za reševanje opisanega problema.

\item S pomočjo dinamičnega programiranja napiši algoritem,
ki rešuje dani problem.
Kakšna je njegova časovna zahtevnost?
\end{enumerate}
\end{vprasanje}
\begin{odgovor}

\begin{enumerate}[(a)]

\item Naj bo $V_i$ največja vsota nesosednjih členov zaporedja, ki jo lahko dobimo,
če gledamo samo elemente od 1 do $i$, in vključuje $a_i$.

\begin{align*}
V_{-1} &= 0 \\
V_0 &= 0 \\
V_i &= \max_{j < i - 1}\left(V_j\right) + a_i
\qquad (i \in \{1, 2, \dots, n\})
\end{align*}

Vidimo, da na i-tem koraku iščemo največjo prejšnjo nesosednjo vsoto $V_j$, 
ki ji bomo priključili element $a_i$, torej izračunamo največjo vsoto, 
ki zadošča pogoju nesosednosti in vključuje člen $a_i$.

Podamo lahko še alternativno rekurzivno zvezo za ta problem, in sicer 
definirajmo $U_i$ kot največjo vsoto nesosednjih členov zaporadja, ki jo dobimo, 
če gledamo samo elemente od 1 do $i$.
Ta definicija se razlikuje od zgornje po tem, da dobljena vsota ne potrebuje nujno 
vključevati elementa $a_i$.

\begin{align*}
U_{-1} &= 0 \\
U_0 &= 0 \\
U_i &= \max\left(U_{j - 2} + a_i, U_{j - 1}\right)
\qquad\ \left(i \in \{1, 2, \dots, n\}\right)
\end{align*}

Ideja tega rekurzivnega zapisa je podobna zgornjemu,
le da se namesto iskanja maximuma, odloči ali bo $i$-ti člen vključila v vsoto, 
ali pa ga bo izpustila

\item Algoritem bo sledil prvi rekurzivni zvezi, 
maximum prejšnjih vsot pa bomo iskali na optimalen način, torej

\begin{algorithmic}
\Function{maxvsota}{$a$}
	\State $n \gets \length(a)$
	\State $\pred \gets [1, 2, \dots, n]$
	\State $V \gets \operatorname{copy}(a)$
	\State tmax $\gets 0$
	\For{$i = 3, 4, \dots, n$}
		\If{$V[i-2] > V$[tmax]}
			\State tmax $\gets i - 2$
		\EndIf
		\If{$V$[tmax] $> 0$}
			\State $V[i] \gets  V[i] + V$[tmax]
			\State $\pred[i] \gets $tmax
		\EndIf
	\EndFor
	\State tmax $\gets \argmax(V[$tmax$], V[n-1], V[n-2])$
	\State pot $\gets$ [tmax]
	\State $t \gets$ tmax
	\While{$\pred[t] \neq t$}
		\State $t \gets \pred[t]$
		\State pot.$\append(t)$
	\EndWhile
	\State pot.$\reverse()$
	\State \Return (pot, $V$[tmax])
\EndFunction
\end{algorithmic}

Kot vidiimo algoritem hrani maximum prejšnjih vsot in spotoma preverja nove kandidate zanj.
Iz tega razloga imamo časovno zahtevnost $\mathcal{O}(n)$, kljub temu, da se je pri zapisu 
rekurzivne formule zdelo, da bi ta lahko bila $\mathcal{O}(n^2)$.

\begin{tabela}
$$
\begin{array}{c|ccccccccc|c}
i & V_1 & V_2 & V_3 & V_4 & V_5 & V_6 & V_7 & V_8 & V_9 & \pred[i]  \\ \hline
0 & -2 & 3 & 10 & -4 & -7 & 41 & 1 & 0 & -10 & 0 \\
3 & -2 & 3 & 10 & -1 & -7 & 41 & 1 & 0 & -10 & 1 \\
4 & -2 & 3 & 10 & -1 & 3 & 41 & 1 & 0 & -10 & 2 \\
5 & -2 & 3 & 10 & -1 & 3 & 51 & 1 & 0 & -10 & 2 \\
6 & -2 & 3 & 10 & -1 & 3 & 51 & 11 & 0 & -10 & 2 \\
7 & -2 & 3 & 10 & -1 & 3 & 51 & 11 & 51 & -10 & 5 \\
8 & -2 & 3 & 10 & -1 & 3 & 51 & 11 & 51 & 41 & 5 \\
\end{array}
$$
\podnaslov{Potek izvajanja algoritma {\sc maxvsota} na  $a = [-2, 3, 10, -4, -7, 41, 1, 0, -10]$}
\end{tabela}

\end{enumerate}

\end{odgovor}
\end{naloga}
