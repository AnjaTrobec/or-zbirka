\razdelek{Zahtevnost algoritmov}

\begin{naloga}{Janoš Vidali}{Vaje OR 21.2.2018}
\begin{vprasanje}
Naj bo $A[1 \dots n][1 \dots n]$ matrika (tj., seznam seznamov)
dimenzij $n \times n$.
Dan je spodnji program:
\begin{small}
\begin{algorithmic}
\For{$i = 1, \dots, n$}
    \For{$j = i+1, \dots, n$}
        \State $A[i][j] \gets A[j][i]$
    \EndFor
\EndFor
\end{algorithmic}
\end{small}

\begin{enumerate}[(a)]
\item Kaj počne zgornji program?
\item Oceni število korakov, ki jih opravi zgornji program,
v odvisnosti od parametra $n$.
\end{enumerate}
\end{vprasanje}

\begin{odgovor}
\begin{enumerate}[(a)]
\item Program prepiše vnose v matriki $A$ nad diagonalo
na ustrezno mesto pod diagonalo tako,
da je po izvedbi programa matrika $A$ simetrična.
\item Kot korak bomo upoštevali posamezno izvedbo notranje zanke {\bf for},
kjer kopiramo vrednost v matriki na drugo mesto
-- ob predpostavki, da je velikost vnosov omejena
(npr.~32-bitna cela števila),
bo trajanje take operacije omejeno s konstanto.
Preštejmo število takih korakov:
$$
\sum_{i=1}^n \sum_{j=i+1}^n 1 = \sum_{i=1}^n (n-i) = \sum_{i=0}^{n-1} i =
{n(n-1) \over 2}
$$

Lahko bi seveda upoštevali še korake,
ki so potrebni za vzdrževanje števcev zank
(inicializacija števca, povečevanje števca, preverjanje konca zanke),
a bi spet dobili kvadratni polinom v $n$.
Tako lahko rečemo, da je število korakov omejeno z $O(n^2)$.
\end{enumerate}
\end{odgovor}
\end{naloga}


\begin{naloga}{Janoš Vidali}{Vaje OR 21.2.2018}
\begin{vprasanje}
Naj bo $\ell[1 \dots n]$ seznam,
ki ima na začetku vse vrednosti nastavljene na $0$.
Dan je spodnji program:

\begin{small}
\begin{algorithmic}
\State $i \gets 1$
\While{$i \le n$}
    \State $\ell[i] \gets 1 - \ell[i]$
    \If{$\ell[i] = 1$}
        \State $i \gets 1$
    \Else
        \State $i \gets i+1$
    \EndIf
\EndWhile
\end{algorithmic}
\end{small}

\begin{enumerate}[(a)]
\item Kaj se dogaja, ko teče zgornji program?
\item Oceni število korakov, ki jih opravi zgornji program,
v odvisnosti od parametra $n$.
\end{enumerate}
\end{vprasanje}

\begin{odgovor}
\begin{enumerate}[(a)]
\item V vsakem obhodu zanke {\bf while}
se vrednost $\ell[i]$ spremeni iz $0$ v $1$ ali obratno.
Če se vrednost spremeni na $1$, se $i$ nastavi na $1$,
sicer se pa poveča za $1$.

Izpišimo si vrednosti v seznamu $\ell$ in spremenljivke $i$
ob koncu vsakega obhoda zanke {\bf while} tekom izvajanja algoritma,
recimo za $n = 4$:
$$
\begin{array}{c|c|ccc|c|c}
\text{obhod} & \ell[4 \dots 1] & i &\qquad&
\text{obhod} & \ell[4 \dots 1] & i \\ \cline{1-3} \cline{5-7}
 1 & 0001 & 1 && 16 & 1001 & 1 \\
 2 & 0000 & 2 && 17 & 1000 & 2 \\
 3 & 0010 & 1 && 18 & 1010 & 1 \\
 4 & 0011 & 1 && 19 & 1011 & 1 \\
 5 & 0010 & 2 && 20 & 1010 & 2 \\
 6 & 0000 & 3 && 21 & 1000 & 3 \\
 7 & 0100 & 1 && 22 & 1100 & 1 \\
 8 & 0101 & 1 && 23 & 1101 & 1 \\
 9 & 0100 & 2 && 24 & 1100 & 2 \\
10 & 0110 & 1 && 25 & 1110 & 1 \\
11 & 0111 & 1 && 26 & 1111 & 1 \\
12 & 0110 & 2 && 27 & 1110 & 2 \\
13 & 0100 & 3 && 28 & 1100 & 3 \\
14 & 0000 & 4 && 29 & 1000 & 4 \\
15 & 1000 & 1 && 30 & 0000 & 5 \\
\end{array}
$$
Če pogledamo samo tiste obhode, na koncu katerih velja $i = 1$, opazimo,
da vrednosti v seznamu $\ell$ predstavljajo
dvojiške zapise števil od $1$ do $2^n - 1$
v ostalih pa se najmanj pomembna $1$ zamenja z $0$.
Algoritem torej simulira dvojiški števec z $n$ mesti.

\item Algoritem obišče vseh $2^n - 1$ števil,
poleg tega pa mora vsakič poskrbeti za zamenjavo vseh enic
za najmanj pomembno ničlo.
Ob upoštevanju, da obstaja $2^{n-i}$ števil
z najmanj pomembno ničlo na $i$-tem mestu,
za vrednost $2^n - 1$ pa je potrebno nadomestiti vseh $n$ mest,
je skupno število korakov enako
\begin{multline*}
n + \sum_{i=1}^n (i \cdot 2^{n-i}) =
\sum_{j=1}^n \left(1 + \sum_{i=j}^n 2^{n-i}\right) = \\
= \sum_{j=1}^n \left(1 + \sum_{i=0}^{n-j} 2^i\right) =
\sum_{j=1}^n 2^{n-j+1} = 2^{n+1} - 2 .
\end{multline*}
Časovna zahtevnost algoritma je torej $O(2^n)$.
\end{enumerate}
\end{odgovor}
\end{naloga}


\begin{naloga}{Janoš Vidali}{Vaje OR 21.2.2018}
\begin{vprasanje}
Algoritem {\sc BubbleSort} uredi vhodni seznam $\ell[1 \dots n]$ tako,
da zamenjuje sosednje elemente v nepravem vrstnem redu:
\begin{small}
\begin{algorithmic}
\Function{BubbleSort}{$\ell[1 \dots n]$}
    \State $z \gets n$
    \While{$z > 1$}
        \State $y \gets 1$
        \For{$i = 2, \dots, z$}
            \If{$\ell[i-1] > \ell[i]$}
                \State $\ell[i-1], \ell[i] \gets \ell[i], \ell[i-1]$
                \State $y \gets i$
            \EndIf
        \EndFor
        \State $z \gets y-1$
    \EndWhile
\EndFunction
\end{algorithmic}
\end{small}

\begin{enumerate}[(a)]
\item Izvedi algoritem na seznamu $[7, 11, 16, 7, 5]$.
\item Določi časovno zahtevnost algoritma.
\end{enumerate}
\end{vprasanje}

\begin{odgovor}
\begin{enumerate}[(a)]
\item Izpišimo vrednosti spremenljivk ob koncu vsakega obhoda zanke {\bf for}
oziroma {\bf while}, ko se prejšnja konča.

$$
\begin{array}{c|c|c|c|c}
\text{obhod {\bf while}} & i & y & z & \ell[1 \dots 5] \\ \hline
1 & 2 & 1 & 5 & [7, 11, 16, 7, 5] \\
1 & 3 & 1 & 5 & [7, 11, 16, 7, 5] \\
1 & 4 & 4 & 5 & [7, 11, 7, 16, 5] \\
1 & 5 & 5 & 5 & [7, 11, 7, 5, 16] \\
1 &   & 5 & 4 & [7, 11, 7, 5, 16] \\
2 & 2 & 1 & 4 & [7, 11, 7, 5, 16] \\
2 & 3 & 3 & 4 & [7, 7, 11, 5, 16] \\
2 & 4 & 4 & 4 & [7, 7, 5, 11, 16] \\
2 &   & 4 & 3 & [7, 7, 5, 11, 16] \\
3 & 2 & 1 & 3 & [7, 7, 5, 11, 16] \\
3 & 3 & 3 & 3 & [7, 5, 7, 11, 16] \\
3 &   & 3 & 2 & [7, 5, 7, 11, 16] \\
4 & 2 & 2 & 2 & [5, 7, 7, 11, 16] \\
4 &   & 2 & 1 & [5, 7, 7, 11, 16] \\
\end{array}
$$

\item Naj bodo $z_1, z_2, \dots, z_k$ vrednosti,
ki jih zavzame spremenljivka $z$ ob vsakem vstopu v zanko {\bf while}.
Očitno velja $z_i - 1 \ge z_{i+1}$ za vsak $i$,
tako da velja $k \le n-1$.
Največje število korakov je torej
$$
\sum_{z=2}^n (z-1) = {n(n-1) \over 2} .
$$
Tako število korakov dosežemo,
če je seznam $\ell$ na začetku urejen padajoče
-- tako vsakič pride do zamenjave v zadnjem koraku zanke {\bf for},
zato se $z$ vsakič zmanjša za $1$.
Časovna zahtevnost algoritma je torej $O(n^2)$.
\end{enumerate}
\end{odgovor}
\end{naloga}


\begin{naloga}{Janoš Vidali}{Vaje OR 12.10.2016}
\begin{vprasanje}[mergesort]
Algoritem {\sc MergeSort} uredi vhodni seznam tako,
da ga najprej razdeli na dva dela,
nato vsakega rekurzivno uredi,
nazadnje pa zlije dobljena urejena seznama.
\begin{enumerate}[(a)]
\item S psevdokodo zapiši algoritem {\sc MergeSort}.
\item Izvedi algoritem na seznamu $[7, 11, 16, 7, 5, 0, 14, 1, 19, 13]$.
\item Določi časovno zahtevnost algoritma.
\end{enumerate}
\end{vprasanje}

\begin{odgovor}
\begin{enumerate}[(a)]
\item
\begin{small}
\begin{algorithmic}
\Function{MergeSort}{$\ell[1 \dots n]$}
    \If{$n \le 1$}
        \State \Return $\ell$
    \EndIf
    \State $m \gets \lceil {n \over 2} \rceil$
    \State $\ell_1 \gets \text{\sc MergeSort}(\ell[1 \dots m])$
    \State $\ell_2 \gets \text{\sc MergeSort}(\ell[m+1 \dots n])$
    \State $i, j \gets 1, 1$
    \State $\ell' \gets []$
    \While{$i \le m \land j \le n-m$}
        \If{$\ell_1[i] \le \ell_2[j]$}
            \State dodaj $\ell_1[i]$ na konec $\ell'$
            \State $i \gets i+1$
        \Else
            \State dodaj $\ell_2[j]$ na konec $\ell'$
            \State $j \gets j+1$
        \EndIf
    \EndWhile
    \State pripni $\ell_1[i \dots m]$ na konec $\ell'$
    \State pripni $\ell_2[j \dots n-m]$ na konec $\ell'$
    \State \Return $\ell'$
\EndFunction
\end{algorithmic}
\end{small}

\item Izvajanje algoritma je prikazano na sliki~\fig{}.
Nad črtkano črto je prikazano rekurzivno razbijanje seznamov,
pod njo pa zlivanje dobljenih urejenih podseznamov.

\item Funkcija obsega dva rekurzivna klica na seznamih polovične dolžine
ter združevanje obeh dobljenih seznamov v enega.
Naj bo $T(n)$ čas izvajanja algoritma pri vhodnem seznamu dolžine $n$.
Ker združevanje poteka v linearnem času, velja rekurzivna zveza
$$
T(n) = O(n) + 2T\left({n \over 2}\right) .
$$
Po krovnem izreku lahko izpeljemo,
da je časovna zahtevnost algoritma $O(n \log n)$.
\end{enumerate}

\begin{slika}
\pgfslika
\podnaslov[\res{}(b)]{Diagram izvajanja algoritma}
\end{slika}
\end{odgovor}
\end{naloga}


\begin{naloga}{Janoš Vidali}{Vaje OR 21.2.2018}
\begin{vprasanje}
Število $n$ želimo razcepiti
na dva netrivialna celoštevilska faktorja,
kar storimo s sledečim algoritmom:
\begin{small}
\begin{algorithmic}
\Function{Razcep}{$n$}
    \For{$i = 2, \dots, \lfloor \sqrt{n} \rfloor$}
        \If{$n/i$ je celo število}
            \State \Return $(i, n/i)$
        \EndIf
    \EndFor
    \State \Return $n$ je praštevilo
\EndFunction
\end{algorithmic}
\end{small}
Določi časovno zahtevnost algoritma.
Ali je ta algoritem polinomski?
\end{vprasanje}

\begin{odgovor}
Algoritem teče v času $O(\sqrt{n})$.
Ker je vhod algoritma število $n$,
ki je zapisano kot zaporedje $\ell = O(\log n)$ bitov,
vidimo, da algoritem teče v času $O(2^{\ell/2})$
in torej ni polinomski v dolžini vhoda.
\end{odgovor}
\end{naloga}


\begin{naloga}{Janoš Vidali}{Vaje OR 21.2.2018}
\begin{vprasanje}
Zapiši rekurziven algoritem,
ki na vhod dobi celo število $n$ in teče v času $O(\sqrt{n})$.
Uporaba korenjenja ni dovoljena.
\end{vprasanje}

\begin{odgovor}
Po krovnem izreku ima časovno zahtevnost $O(\sqrt{n})$ algoritem,
katerega čas izvajanja $T(n)$ je opisan z rekurzivno zvezo
$$
T(n) = O(1) + 2T\left({n \over 4}\right) .
$$
Zapišimo tak algoritem:
\begin{small}
\begin{algorithmic}
\Function{Korenski}{$\ell[1 \dots n]$}
    \If{$n \ge 4$}
        \State $m \gets \lfloor {n \over 4} \rfloor$
        \State $\text{\sc Korenski}(\ell[1 \dots m])$
        \State $\text{\sc Korenski}(\ell[n-m+1 \dots n])$
    \EndIf
\EndFunction
\end{algorithmic}
\end{small}
\end{odgovor}
\end{naloga}


\begin{naloga}{?}{Kolokvij OR 17.4.2013}
\begin{vprasanje}
Dani so končna neprazna množica $S \subset \N$ moči $n$,
število $k \in \{1, 2, \dots, n\}$ ter algoritem {\sc Alg}:
\begin{small}
\begin{algorithmic}
\Function{Alg}{$S, k$}
    \State $x \gets$ naključen element $S$
    \State $S^+ \gets \set{y \in S}{y > x}$
    \State $S^- \gets \set{y \in S}{y < x}$
    \If{$|S^-| < k-1$}
        \State \Return {\sc Alg}$(S^+, k - |S^-| - 1)$
    \ElsIf{$|S^-| = k-1$}
        \State \Return $x$
    \Else
        \State \Return {\sc Alg}$(S^-, k)$
    \EndIf
\EndFunction
\end{algorithmic}
\end{small}
Ugotovi, kaj je izhod algoritma pri danih vhodnih podatkih $S$ in $k$.
Oceni časovno zahtevnost algoritma v najslabšem in v povprečnem primeru.
\end{vprasanje}

\begin{odgovor}
Algoritem poišče $k$-ti najmanjši element v množici $S$.
Množico razdeli na dva dela glede na naključno izbrani element $x$.
Če ima množica $S^-$ elementov, manjših od $x$, natanko $k-1$ elementov,
potem je $x$ iskani element.
Če ima $S^-$ manj kot $k-1$ elementov,
algoritem rekurzivno poišče $(|S^-| - k - 1)$-ti element
v množici $S^+$ elementov, večjih od $x$,
sicer pa rekurzivno poišče $k$-ti element v množici $|S^-|$.

V najslabšem primeru je velikost množice,
ki jo algoritem rekurzivno preišče, enaka $n - 1$.
Ker algoritem porabi $O(n)$ korakov za razporejanje elementov po množicah,
v najslabšem primeru za čas izvajanja $T(n)$ velja
$$
T(n) = O(n) + T(n-1) = O\left(\sum_{i=0}^n (n-i)\right) = O(n^2).
$$

Poglejmo si sedaj povprečni čas izvajanja $\hat{T}(n)$.
Denimo, da je izbrani element $x$ $j$-ti po vrsti.
Če velja $j = k$, potem algoritem konča.
Če velja $j < k$, potem algoritem rekurzivno pregleda
množico $S^+$ z $n-j$ elementi,
če pa velja $j > k$, pa pregleda množico $S^-$ z $j-1$ elementi.
Zapišimo rekurzivno zvezo za $\hat{T}(n)$:
$$
\hat{T}(n) = O(n) +
{1 \over n} \left(\sum_{j=1}^{k-1} \hat{T}(n-j) +
\sum_{j=k+1}^n \hat{T}(j-1) \right)
$$
Denimo, da je čas izvajanja nerekurzivnega dela funkcije
omejen s $c \cdot n$ koraki za neko konstanto $c > 0$.
Z indukcijo bomo pokazali,
da velja $\hat{T}(n) \le C \cdot n$ za neko konstanto $C > 0$.

Po zgornji predpostavki velja $\hat{T}(1) \le cn$.
Denimo, da za vse $m < n$ velja $\hat{T}(m) \le Cm$.
Potem velja
\begin{align*}
\hat{T}(n) &\le cn +
{1 \over n} \left(\sum_{j=1}^{k-1} C(n-j) +
\sum_{j=k+1}^n C(j-1) \right) \\
&= cn + {C \over 2n} ((2n-k)(k-1) + (n+k-1)(n-k)) \\
&= cn + {C \over 2n} (n^2 + 2nk - 3n - 2k^2 + 2k) \\
&= \left(c + {C \over 2}\right) n + {C(2k - 3) \over 2} - {Ck(k-1) \over n}
\end{align*}
Označimo sedaj $\alpha = k/n$ -- velja torej $0 < \alpha \le 1$.
\begin{align*}
\hat{T}(n) &\le
\left(c + C \left({1 \over 2} + \alpha - \alpha^2\right) \right) n
+ C \left(\alpha - {3 \over 2}\right) \\
&\le \left(c + C \left({1 \over 2} + \alpha (1 - \alpha)\right) \right) n \\
&\le \left(c + {3C \over 4} \right) n
\end{align*}
Če vzamemo $C \ge 4c$,
potem po indukciji velja $\hat{T}(n) \le Cn$ za vse $n$.
Algoritem torej v povprečnem primeru opravi $O(n)$ korakov.
\end{odgovor}
\end{naloga}

\begin{naloga}{?}{Kolokvij OR 25.11.2010}
\begin{vprasanje}
\begin{enumerate}[(a)]
\item Dokaži, da za poljubni konstanti $a, b \in \R$, kjer je $b > 0$,
velja ${(n + a)}^b = O(n^b)$.

\item Naj bo $f$ naraščajoča funkcija.
Ali velja $g(n) = O(f(g(n)))$?

\item Dokaži,
da če $T$ zadošča pogoju $T(n) = 2T(\lceil n/2 \rceil) - 13$ za $n \ge 2$,
potem je $T(n) = O(n)$.
\end{enumerate}
\end{vprasanje}
\begin{odgovor}
\end{odgovor}
\end{naloga}


\begin{naloga}{?}{Kolokvij OR 4.5.2012}
\begin{vprasanje}
Naj bo $G = (V, E)$ enostaven usmerjen graf
(tj., brez zank in vzporednih povezav),
podan z matriko sosednosti $A = (a_{ij})_{i,j=1}^n$ ($n = |V|$),
kjer je $a_{ij} = 1$, če je $ij \in E$, in $a_{ij} = 0$ sicer.
Želimo ugotoviti, ali v $G$ obstaja kak usmerjen trikotnik
(tj., usmerjen cikel dolžine $3$).
\begin{enumerate}[(a)]
\item Konrad je napisal naslednji algoritem, ki naj bi rešil ta problem:
\begin{small}
\begin{algorithmic}
\For{$i = 1, \dots, n$}
    \For{$j = 1, \dots, n$}
        \For{$k = 1, \dots, n$}
            \For{$\ell = 1, \dots, n$}
                \If{$a_{ij} = a_{jk} = a_{j\ell} = 1 \land \ell = i$}
                    \State \Return{\sc True}
                \EndIf
            \EndFor
        \EndFor
    \EndFor
\EndFor
\State \Return{\sc False}
\end{algorithmic}
\end{small}
Ali algoritem deluje pravilno?
Kakšna je njegova časovna zahtevnost?

\item V psevdokodi napiši algoritem, ki reši problem v času $O(n^3)$.
Koliko korakov naredi tvoj algoritem v najboljšem
in koliko v najslabšem primeru?
\end{enumerate}
\end{vprasanje}
\begin{odgovor}
\end{odgovor}
\end{naloga}


\begin{naloga}{?}{Izpit OR 26.6.2012}
\begin{vprasanje}
Dr.~Kaczyński se ukvarja s podatkovno strukturo $A$,
ki je zelo podobna tabeli (angl.~{\em array}) celih števil.
Vrednosti v posameznih celicah ``tabele'' $A$ lahko beremo,
ne moremo pa jih spreminjati.
Elementi ``tabele'' $A$ so indeksirani s celimi števili od $1$ do $n$,
kjer je $n = A.length()$ indeks zadnjega elementa ``tabele'' $A$.
Edina operacija (poleg dostopanja do posameznih elementov),
ki jo lahko izvajamo nad $A$, je ``obračanje podtabele''.
Če ima na začetku $A$ vrednosti
$$
A = [a_1, a_2, \dots, a_{i-1}, a_i, a_{i+1}, \dots, a_{j-1}, a_j, a_{j+1},
     \dots, a_{n-1}, a_n],
$$
po klicu ukaza $A.obrni(i, j)$ izgleda takole:
$$
A = [a_1, a_2, \dots, a_{i-1}, a_j, a_{j-1}, \dots, a_{i+1}, a_i, a_{j+1},
     \dots, a_{n-1}, a_n] .
$$
Dr.~Kaczyński se je lotil implementacije algoritmov
nad to podatkovno strukturo.
Najprej je seveda implementiral algoritem za urejanje:
\begin{small}
\begin{algorithmic}
\State $n \gets A.length()$
\For{$i = 2, \dots, n$}
    \State $j \gets i$
    \While{$j > 1 \land A[j-1] > A[i]$}
        \State $j \gets i-1$
    \EndWhile
    \State $A.obrni(j, i)$
    \If{$j+1 < i$}
        \State
    \EndIf
\EndFor
\end{algorithmic}
\end{small}

\begin{enumerate}[(a)]
\item V zgornji algoritem se je prikradla manjša tipkarska napaka,
poleg tega pa je ena vrstica celo izginila.
Popravi algoritem, da bo deloval pravilno.

\item Popravljeni algoritem izvedi na ``tabeli'' $A = [5, 3, 12, 9, 1, 15]$.
\end{enumerate}
\end{vprasanje}
\begin{odgovor}
\end{odgovor}
\end{naloga}


\begin{naloga}{?}{Izpit OR 9.7.2012}
\begin{vprasanje}
Dan je algoritem $H$,
ki na vhod sprejme enostaven neusmerjen graf $G = (V, E)$
(tj., brez zank in vzporednih povezav)
ter različni vozlišči $u, v \in V$:
\begin{small}
\begin{algorithmic}
\Function{$H$}{$G, u, v$}
    \If{$|V| = 2 \land u \in sosedi(v)$}
        \State \Return{\sc True}
    \EndIf
    \For{$w \in sosedi(u) \setminus \{v\}$}
        \If{$H(G - u , w, v)$}
            \State \Return{\sc True}
        \EndIf
    \EndFor
    \State \Return{\sc False}
\EndFunction
\end{algorithmic}
\end{small}
Oznaka $G - u$ predstavlja graf,
ki ga dobimo iz $G$ tako, da odstranimo vozlišče $u$ in vse njegove povezave.

\begin{enumerate}[(a)]
\item Za katere vhode $(G, u, v)$ algoritem $H$ vrne {\sc True}?
\namig{poglej, kako je z grafi z $2, 3, 4, 5, \dots$ vozlišči,
in poskusi posplošiti.}

\item Denimo, da je $G = (V, E)$ graf z $n$ vozlišči,
pri čemer je vozlišče $v$ izolirano (tj., nima nobene povezave),
med vsakima drugima dvema vozliščema pa imamo povezavo.
Pokaži, da se pri klicu $H(G, u, v)$ (kjer je $u \in V \setminus \{v\}$)
zadnja vrstica funkcije $H$ izvede $\Theta((n-2)!)$-krat.
\end{enumerate}
\end{vprasanje}
\begin{odgovor}
\end{odgovor}
\end{naloga}


\begin{naloga}{?}{Izpit OR 4.9.2012}
\begin{vprasanje}
Dr.~Kaczyński se ukvarja s podatkovno strukturo $A$,
ki je zelo podobna tabeli (angl.~{\em array}) celih števil.
Vrednosti v posameznih celicah ``tabele'' $A$ lahko beremo,
ne moremo pa jih spreminjati.
Elementi ``tabele'' $A$ so indeksirani s celimi števili od $1$ do $n$,
kjer je $n = A.length()$ indeks zadnjega elementa ``tabele'' $A$.
Edina operacija (poleg dostopanja do posameznih elementov),
ki jo lahko izvajamo nad $A$, je $A.obrniZacetek(i)$.
Če ima na začetku $A$ vrednosti
$$
A = [a_1, a_2, \dots, a_{i-1}, a_i, a_{i+1}, \dots, a_{n-1}, a_n],
$$
po klicu ukaza $A.obrniZacetek(i)$ izgleda takole:
$$
A = [a_i, a_{i-1}, \dots, a_2, a_1, a_{i+1}, \dots, a_{n-1}, a_n] .
$$
Dr.~Kaczyński se je lotil implementacije algoritmov
nad to podatkovno strukturo.
Najprej je seveda implementiral algoritem za urejanje:
\begin{small}
\begin{algorithmic}
\State $n \gets A.length()$
\For{$i = n, \dots, 2$}
    \For{$j = 1, \dots, i-1$}
        \If{$A[j] > A[i]$}
            \State $A.obrniZacetek(j)$
            \State $A.obrniZacetek(i)$
        \EndIf
    \EndFor
\EndFor
\end{algorithmic}
\end{small}

\begin{enumerate}[(a)]
\item Oceni časovno zahtevnost zgornjega algoritma.
Upoštevaj, da se operacija $A.obrniZacetek(i)$ izvede v konstantnem času.

\item Algoritem izvedi na ``tabeli'' $A = [5, 9, 12, 7, 15]$.
Ali deluje pravilno?

\item Napiši algoritem za urejanje, ki bo deloval pravilno.
Njegova časovna zahtevnost ne sme biti slabša
od časovne zahtevnosti algoritma Dr.~Kaczyńskega.
\end{enumerate}
\end{vprasanje}
\begin{odgovor}
\end{odgovor}
\end{naloga}
