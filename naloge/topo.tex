\begin{naloga}{Janoš Vidali}{Vaje OR 7.12.2016}
\begin{vprasanje}
Dan je usmerjen acikličen graf s slike~\fig.

\begin{enumerate}[(a)]
\item Poišči topološko ureditev vozlišč zgornjega grafa.

\item Poišči najkrajšo pot od vozlišča $g$ do vozlišča $e$.

\item Poišči najdaljšo pot od vozlišča $g$ do vozlišča $e$.
\end{enumerate}

\begin{slika}
\pgfslika
\podnaslov{Graf}
\end{slika}
\end{vprasanje}
\begin{odgovor}

\begin{enumerate}[(a)]
\item Upoštevamo, da je graf $G = (V, E)$ acikličen, torej za vsaki vozlišči $u, v \in V$ velja: \\[5px]
$u \rightarrow v \implies \operatorname{pooznaka}(u)$ \ \textgreater \ $\operatorname{pooznaka}(v)$, \\[5px]
kjer je pooznaka števec s katerim označimo vozlišče, ko ga v algoritmu ${\sc dfs}$ docela preiščemo.

Trditev lahko dokažemo z obravnavanjem dveh primerov, in sicer, 
ko z ${\sc dfs}$ pridemo v vozlišče $u$ pred $v$ in ko pridemo v vozlišče $v$ pred $u$.
V prvem primeru bomo pred določitvijo pooznake vozlišču $u$ morali obiskati vse njegove
sosede, torej $v$, kateremu bomo določili pooznako pred $u$.
V drugem primeru pridemo prvo do $v$, a ker je graf acikličen, od $v$ ne bomo prišli do $u$, torej
bomo spet $v$ obdelali prej.

Trditev nam omogoča zapis krajšega algoritma, ki bo implementiral ${\sc dfs}$.
Njegova ideja je, da padajoče uredimo vozlišča po njihovih pooznakah, 
in tako dobimo inverzno topološko ureditev.
To pa dosežemo tako, da po popolni obdelavi vozlišča, tega položimo na sklad.

\begin{small}
\begin{algorithmic}
\Function{Topo}{$G = (V, E)$}
	\State $n \gets \length(V)$
	\State oznaceni $\gets$ slovar z vrednostjo $\False$ za vsako vozlišče iz $V$
	\State toposklad $\gets []$
	\Function{dfs}{$u$}
		\State oznaceni[u] = \True
		\For{$v \in \Adj(u)$}
			\If{$\lnot$ oznaceni[$v$]}
				\State dfs(v)
			\EndIf
		\EndFor
		\State toposklad.\append(u)
	\EndFunction
	\For{$u \in V$}
		\If{$\lnot$ oznaceni[$v$]}
			\State dfs(v)
		\EndIf
	\EndFor
	\State \Return \reverse(toposklad)
\EndFunction
\end{algorithmic}
\end{small}

Po klicu $\operatorname{topo}(G)$, nam ta vrne ureditev vozlišč $[g, a, h, b, c, f, d, e]$.

\item Tukaj bomo uporabili rezultat prejšnje naloge in osnoven 
koncept dinamičnega programiranja.

Označimo z $\ell(u, v)$ utež povezave $u \rightarrow v$.
Naj $\operatorname{d_G}(u)$ predstavlja najkrajšo razdaljo od vozlišča $g$ do $u$

\begin{align*}
d_G(g) &= 0 \\
d_G(u) &= \min_{v \rightarrow u}(d_G(v) + \ell(v, u))
\end{align*}

Da bomo imeli vse potrebovane $d_G(v)$ definirane pred klicom $d_G(u)$
poskrbimo z rezultatom prejšnje naloge, saj pri topološki ureditvi vodijo vse povezave le naprej, 
torej po premiku na naslednje vozlišče ne potrebujemo vozlišč po, a le ta pred njim,
katera pa že imamo.

Torej imamo vse kar potrebujemo za izračun najkrajše poti, 
za beleženje vozlišč skozi katera vodi ta pot pa bomo uporabili seznam predhodnikov, 
ki bo nakazoval katero vozlišče smo izbrali za predhodnika, torej
\begin{align*}
predhodnik(G) &= None \\
predhodnik(u) &= argmin_{v \rightarrow u}(d_G(v) + \ell(v, u))
\end{align*}
Na koncu dobimo pot tako da sledimo predhodnikom $e$, dokler ne pridemo do $g$.  

\begin{small}
\begin{algorithmic}
\Function{najkrajšaPot}{$G = (V, E), s, e$}
	\State $n \gets \length(V)$
	\State topo $\gets {\sc Topo}((V, E))$
	\State $d_G \gets$ slovar z vrednostjo $\infty$ za vsako vozlišče $v \in V$
	\State $d_G[s] \gets 0$
	\State predhodniki $\gets$ slovar z vrednostjo None za vsako vozlišče $v \in V$
	\For{$\forall u \in \text{topo}$}
		\For{$v \in \Adj(u)$}
			\If{$d_G[v] \ \textgreater \ d_G[u] \ell(u, v)$}
				\State $d_G[v] \gets d_G[u] + \ell(u, v)$
				\State predhodniki[v] $\gets u$
			\EndIf
		\EndFor
	\EndFor
	\State pot $\gets [e]$
	\While{predhodnik[pot[-1]] $\notin \{s, None\}$}
		\State pot.$\append$(predhodniki[pot[-1]])
	\EndWhile
	\State \Return $d_G[e]$, $\reverse$(pot)
\EndFunction 
\end{algorithmic}
\end{small}

Premislimo kaj nam vrne algoritem, ko pokličemo ${\sc najkrajšaPot}(G, g, e)$.
Vrne nam dolžino od vozlišča $g$ do $e$, kot drugi argument pa vrne vozlišča, 
skozi katera je algoritem potoval, da je opravil to pot, to pa so $[g, a, b, e]$. 

Pripomnimo, da algoritem deluje pravilno, ker iščemo razdaljo od $g$ naprej, saj je 
$g$ začetno vozlišče v topološki ureditvi in nima predhodnika, torej se bo algoritem, 
ki išče pot preko predhodnikov ustavil po tem, ko pride do $g$.
Algoritem lahko posplošimo tako, da gledamo vozlišča v topološki ureditvi le od $s$ naprej, 
prejšnja pa ignoriramo, saj iz $s$ ne moremo priti do njih.

\item Postopamo kot v prejšnjem algoritmu, le da namesto $\infty$ vzamemo v $d_G $
za začetne vrednosti $-\infty$, v zanki pa na vsakem koraku preverjamo pogoj  
$d_G[v] \ \textgreater \ d_G[u] + \ell(u, v)$ .
Poleg teh sprememb je algoritem identičen.
Vrne nam $[g, h, b, c, d, e]$.

\end{enumerate}

\end{odgovor}
\end{naloga}
